<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
    <!-- Import main JS file -->
    <script type="module" src="./js/main.js"></script>
    
    <!-- Orbit Controls -->
    <!-- <script src="./node_modules/three/examples/jsm/controls/OrbitControls.js"></script> -->

    <!-- GSAP 3 Library for Animation  -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.0/gsap.min.js"></script> -->

    <!-- 3D Canvas Rendering Script (ThreeJS + GSAP 3) -->
    <script>
        // // 3 primary components: scene, camera and renderer
        // const scene = new THREE.Scene();

        // // Camera takes 4 params: FOV (degrees), Aspect Ratio (Width / Height), Near Clipping Plane, Far Clipping Plane
        // const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // camera.position.z = 10; // Set camera position
        
        // const renderer = new THREE.WebGLRenderer({antialias: true});

        // const orbit = new THREE.OrbitControls( camera, renderer.domElement ) //Orbit Controls for camera 
        
        // // Renderer settings:
        // renderer.setClearColor("#E5E5E5");
        // renderer.setSize(window.innerWidth, window.innerHeight);
        
        // // Add renderer to HTML as a canvas element
        // document.body.appendChild(renderer.domElement);

        // // Make canvas responsive
        // window.addEventListener('resize', () => {
        //     renderer.setSize(window.innerWidth, window.innerHeight); // Update size
        //     camera.aspect = window.innerWidth / window.innerHeight; // Update aspect ratio
        //     camera.updateProjectionMatrix();
        // })

        // // Determine which boxMesh is being clicked
        // const raycaster = new THREE.Raycaster();
        // const mouse = new THREE.Vector2();

        // // Create sphere: Available params at https://threejs.org/docs/#api/en/geometries/SphereGeometry
        // const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32); // Define geometry
        // const sphereMaterial = new THREE.MeshLambertMaterial({color: 0xFF0000}) // Define material
        // const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial); // Build sphere
        // sphereMesh.position.set(10, 0, 0)
        // scene.add(sphereMesh); // Add sphere to canvas

        // // Orbiting Sphere tutorial can be found here: https://mattloftus.github.io/2016/02/03/threejs-p2/
        // //Set the sphere's orbital radius, start angle, and angle increment value
        // const r = 5; // Radius of orbit
        // let theta = 0; // Starting angle
        // const dTheta = 2 * Math.PI / 150; // Angle increment on each render (100 = increments to complete revolution)

        // // Create box: Available params at https://threejs.org/docs/#api/en/geometries/SphereGeometry
        // const boxGeometry = new THREE.BoxGeometry(5, 5, 5); // Define geometry
        // const boxMaterial = new THREE.MeshLambertMaterial({color: 0x293BE0}) // Define material

        // // Add one box with pivot
        // const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial); // Build box
        // boxMesh.rotation.set(40, 0, 40); // Set box position

        // //Make a pivot
        // // const boxPivot = new THREE.Object3D();
        // // boxPivot.add(boxMesh); //Add boxMesh to pivot
        // // boxMesh.position.set(new THREE.Vector3(0,0,0)); //Move boxMesh away from pivot
        // // boxPivot.rotation.y = Math.PI / 2; //rotate the boxMesh 90 degrees around pivot
        // scene.add(boxMesh); // Add box to canvas

        // // Add light to scene
        // const light1 = new THREE.PointLight(0XFFFFFF, 1, 500);
        // light1.position.set(0, 0, 25); // Set light position
        // scene.add(light1); // Add light to canvas


        // // Add light to scene
        // const light2 = new THREE.PointLight(0XFFFFFF, 1, 200);
        // light2.position.set(10, -5, 0); // Set light position
        // scene.add(light2); // Add light to canvas
 
        // // Ensure model aspect ratio is readjusted when screen size and screen aspect ratio change
        // const render = function() {
        //     requestAnimationFrame(render); // Rerender every time the page refreshes (pause when on another tab)

        //     // Rotate box
        //     boxMesh.rotation.z -= 0.002;

        //     //Increment theta, and update sphere x and y
        //     //position based off new theta value        
        //     theta += dTheta;
        //     sphereMesh.position.x = r * Math.cos(theta);
        //     sphereMesh.position.z = r * Math.sin(theta);

        //     renderer.render(scene, camera);
        // }

        // render();

    </script> 
</body>
</html>